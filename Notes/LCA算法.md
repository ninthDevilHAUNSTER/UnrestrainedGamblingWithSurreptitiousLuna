---
typora-copy-images-to: ..\img
---

# LCA 算法

> Tarjan 算法。一次遍历解决所有查询，复杂度为O(n+q)。
>
> 它是一个离线的算法，也就是说，所有查询，一次性输入，一次性输出。



### 基本思路

**1.任选一个点为根节点，从根节点开始。**

**2.遍历该点u所有子节点v，并标记这些子节点v已被访问过。**

**3.若是v还有子节点，返回2，否则下一步。**

**4.合并v到u上。（利用并查集优化）**

**5.寻找与当前点u有询问关系的点v。**

**6.若是v已经被访问过了，则可以确认u和v的最近公共祖先为v被合并到的父亲节点a。**



### 手动模拟

**初始化**

```c++
1 2 4 7 5 8 3 6
4 7 2 5 8 1 3 6
利用上述先序与中序序列建树
查询序列
    7 8 
    5 6
    5 2
    4 6
```

将vis数组全置`false`，另需要一个father数组记录祖先关系

```c++
fill(vis,vis+N,false);
for(int i=1; i<=N;i++) father[i] = i;
```

**取1为根节点**

- 遍历1的子节点，发现2和3
- 遍历2的子节点（先左后右），发现4。一路往右遍历到7。7没有叶子节点，所以 `vis[7] = true`
- 发现7要查的是8，但是8还没有访问，所以先不管。
- 向上回溯，可以得到 father[7] = 4
- 此时发现4的叶节点已经遍历完了，那就`vis[4] = true`
- 发现4要查的是6，但是6还没访问，先跳过
- 向上回溯，更新可得father[4] = 2
- 继续遍历2的子节点，一路向下遍历到8,。8没有叶子节点，所以`vis[8] = true`
- 发现8要查的是7,7已经访问了，所以现在就是`findFather(7)`可以得到答案。
- 向上回溯，可以得到 father[8] = 5
- 此时发现5的叶节点已经遍历完了，那就`vis[5] = true `
- 发现5要查的是6，6已经访问，现在就是`findFather(6)`可以得到答案。
- 相同的过程不再重复。

